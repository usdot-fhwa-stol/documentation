<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Carma-platform: carma_wm</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Carma-platform<span id="projectnumber">&#160;v4.2.0</span>
   </div>
   <div id="projectbrief">CARMA Platform is built on robot operating system (ROS) and utilizes open source software (OSS) that enables Cooperative Driving Automation (CDA) features to allow Automated Driving Systems to interact and cooperate with infrastructure and other vehicles through communication.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_carma_wm_README.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title"><a class="el" href="namespacecarma__wm.html">carma_wm</a> </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p >This package provides the <a class="el" href="namespacecarma__wm.html">carma_wm</a> C++ library which manages and simplifies accessing and querying the road network that the vehicle is operating in. This package makes heavy use of the <a href="https://github.com/fzi-forschungszentrum-informatik/Lanelet2">Lanelet2 C++ Library</a> to represent road geometry and communicate with the rest of the CARMA Platform. A copy of the Lanelet2 License can be found <a class="el" href="md_carma_wm_doc_LANELET2_LICENSE.html">here</a>. <br  />
</p>
<h1><a class="anchor" id="autotoc_md9"></a>
Library Role</h1>
<p >The <a class="el" href="namespacecarma__wm.html">carma_wm</a> library design was inspired by the <a href="http://wiki.ros.org/tf2">tf2 library</a> in that it provides automatic subscription and message callbacks for semantic map and route updates in CARMA. Beyond this the library is designed for support a wider range of route-based computations than Lanelet2 provides by default, however it is expected that users will learn and use the Lanelet2 API directly for most non-route based needs. The library provides read-only access to the map and route objects. Map and route updating is handled by other components in the CARMA Platform. <br  />
</p>
<h1><a class="anchor" id="autotoc_md10"></a>
CARMA Lanelet2 OSM File Format Changes</h1>
<p >By default Lanelet2 supports a modified version of the OpenStreetMaps (OSM) file format to describe its roadways. See <a href="https://github.com/fzi-forschungszentrum-informatik/Lanelet2/blob/master/lanelet2_maps/README.md">here</a> for an introduction. Part of this standard describes how road regulations are defined by interpreting tags on various Lanelet2 primitives. In addition, regulatory elements also fill a similar role. Unfortunately, this creates a confusing situation where some regulations are tied intrinsically to the physical markings on the road. For example, a double yellow line could never be crossed even if nearby signs instructed the user to do so around a work zone. To resolve this, while also preserving the description of the physical markings on the road, CARMA Platform supports an additional set of <a href="https://github.com/usdot-fhwa-stol/autoware.ai/blob/carma-develop/common/lanelet2_extension/docs/RegulatoryElements.md">regulatory elements</a>. Using these regulations separates all road regulations from physical road markings allowing for situations such as the work zone use case described above. In addition, all Lanelet2 Maps must follow the Autoware.ai tagging specification rules described in this document and <a href="https://github.com/usdot-fhwa-stol/autoware.ai/blob/carma-develop/common/lanelet2_extension/docs/lanelet2_format_extension.md">here</a> due to the use of legacy map handling nodes. This is a requirement which may be depercated in the future. If a Lanelet2 map is loaded which does not contain these elements the <a class="el" href="namespacecarma__wm__ctrl.html">carma_wm_ctrl</a> package will make a best effort attempt to add them using Lanelet2's default tagging rules before forwarding the map to components using the <a class="el" href="namespacecarma__wm.html">carma_wm</a> library.</p>
<h1><a class="anchor" id="autotoc_md11"></a>
Route Definition</h1>
<p >LaneLet2 provides its own routing module. Details of this module can be found <a href="https://github.com/fzi-forschungszentrum-informatik/Lanelet2/tree/master/lanelet2_routing">here</a> and should be reviewed before continuing in with this section. Lanelet2 generates a route by finding the shortest path of LaneLets between two points according to a user defined cost function. Then it will identify all the LaneLets which lie along the same roads as this path and include them in the description. The sequence of LaneLets which describe the original shortest path will also be preserved inside the route object. This can be seen below.</p>
<p ><img src="doc/media/path_vs_route.png" alt="" class="inline"/> Depiction of shortest path compared with Lanelet2 route Images sourced from Lanelet2 routing documentation found <a href="https://github.com/fzi-forschungszentrum-informatik/Lanelet2/tree/master/lanelet2_routing">here</a>.</p>
<p >To support the concept of downtrack and crosstrack distance often used for planning in cooperative applications the reference line will be defined by the center lines which lie along the routeâ€™s shortest path. This will remove ambiguity in where the reference line is located on the road as shown below.</p>
<p ><img src="doc/media/DowntrackReference.png" alt="" class="inline"/> Route line for calculating downtrack distance</p>
<p >When there are lane changes that occur along the route the line of reference will move to the following lane after the lane change lanelet as shown below. This will prevent the length of the adjacent lanelet being double counted. <br  />
</p>
<p ><img src="doc/media/ReferenceLine.png" alt="" class="inline"/> Route reference line at lane change location. Image sourced from Lanelet2 publication found <a href="https://www.mrt.kit.edu/z/publ/download/2018/Poggenhans2018Lanelet2.pdf">here</a></p>
<h1><a class="anchor" id="autotoc_md12"></a>
Example Usage</h1>
<h2><a class="anchor" id="autotoc_md13"></a>
Initialization</h2>
<p >Users should initialize the <a class="el" href="namespacecarma__wm.html">carma_wm</a> by first creating an instance of the <a href="include/carma_wm/WMListener.h">WMListener</a> object. This will automatically subscribe to the <code>semantic_map</code> and <code>route</code> topics which will provide map and route updates. By default the WMListener is single threaded and will only trigger callbacks when <code>ros::spin()</code> is called. However, as map and route updates can be time consuming there is a multi-threaded mode which can be enabled using WMListener constructor. This will use a <code>ros::AsyncSpinner</code> to update the map and route in the background. When this happens the user should take care to ensure thread safety when performing map or route access through the use of the <code>WMListener.getLock()</code> method. <br  />
</p>
<p >Once the user decides they need to access map or route information, they will do so through an instance of the <a href="include/carma_wm/WorldModel.h">WorldModel</a> interface. This provides read access to map and route objects as well as functions for quickly computing downtrack or crosstrack distances. An instance of the WorldModel can be acquired using the <code>WMListener.getWorldModel()</code> method. The WorldModel object is not thread safe on its own which is why usage of the <code>WMListener.getLock()</code> method is critical when using multi-threaded mode.</p>
<h3><a class="anchor" id="autotoc_md14"></a>
Single Threaded Example Code</h3>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">#include &lt;ros/ros.h&gt;</div>
<div class="line">#include &lt;carma_wm/WMListener.h&gt;</div>
<div class="line">#include &lt;carma_wm/WorldModel.h&gt;</div>
<div class="line">int main(int argc, char **argv)</div>
<div class="line">{</div>
<div class="line">  ros::init(argc, argv, &quot;map_user&quot;);</div>
<div class="line"> </div>
<div class="line">  // Create WMListener after initializing ros</div>
<div class="line">  // It is recommended only one instance be created per node</div>
<div class="line">  carma_wm::WMListener wml; // Create single threaded listener instance. Equivalent to carma_wm::WMListener wml(false);</div>
<div class="line"> </div>
<div class="line">  carma_wm::WorldModelConstPtr wm = wml.getWorldModel(); // Get pointer to WorldModel</div>
<div class="line"> </div>
<div class="line">  ros::Rate loop_rate(10);</div>
<div class="line">  while (ros::ok())</div>
<div class="line">  {</div>
<div class="line"> </div>
<div class="line">    if (wml.getRoute()) { // Route object provided a shared_ptr so you can use it to check for availability</div>
<div class="line">      lanelet::Point3d pt;</div>
<div class="line"> </div>
<div class="line">      carma_wm::TrackPos tc = wm-&gt;routeTrackPos(pt); // Get the downtrack and crosstrack position of the provided point on the route</div>
<div class="line">    }</div>
<div class="line">    ros::spinOnce();</div>
<div class="line"> </div>
<div class="line">    loop_rate.sleep();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md15"></a>
Multi-Threaded Example Code</h3>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">#include &lt;ros/ros.h&gt;</div>
<div class="line">#include &lt;atomic&gt;</div>
<div class="line">#include &lt;carma_wm/WMListener.h&gt;</div>
<div class="line">#include &lt;carma_wm/WorldModel.h&gt;</div>
<div class="line">int main(int argc, char **argv)</div>
<div class="line">{</div>
<div class="line">  ros::init(argc, argv, &quot;map_user&quot;);</div>
<div class="line"> </div>
<div class="line">  // Create WMListener after initializing ros</div>
<div class="line">  // It is recommended only one instance be created per node</div>
<div class="line">  carma_wm::WMListener wml(true); // Create multi-threaded listener instance by passing true constructor parameter</div>
<div class="line"> </div>
<div class="line">  carma_wm::WorldModelConstPtr wm = wml.getWorldModel(); // Get pointer to WorldModel</div>
<div class="line"> </div>
<div class="line">  std::atomic&lt;bool&gt; routeReady(false);</div>
<div class="line">  wml.setRouteCallback([&amp;]() { // User can set callback to trigger when a new route or map is received. Works in single threaded case as well</div>
<div class="line">   routeReady.store(true);</div>
<div class="line">  });</div>
<div class="line"> </div>
<div class="line">  ros::Rate loop_rate(10);</div>
<div class="line">  while (ros::ok())</div>
<div class="line">  {</div>
<div class="line"> </div>
<div class="line">    auto lock = wml.getLock(); // Acquire lock. Now user can safely access map and route data</div>
<div class="line">    if (routeReady) { </div>
<div class="line">      lanelet::Point3d pt;</div>
<div class="line">      carma_wm::TrackPos tc = wm-&gt;routeTrackPos(pt); // Get the downtrack and crosstrack position of the provided point on the route</div>
<div class="line">    }</div>
<div class="line">    ros::spinOnce();</div>
<div class="line"> </div>
<div class="line">    loop_rate.sleep();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md16"></a>
Unit Test Example Pseudo Code</h3>
<p >To better support unit testing, the user should define their classes or functions to take in the pointer to the world model provided by WMListener. In the unit test, they can then intialize an instance of CARMAWorldModel, and set the map and route manually. NOTE: CARMAWorldModel should not be used in runtime code as the map route synchronization will need to be manually maintained.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">TEST(UserTest, someTest)</div>
<div class="line">{</div>
<div class="line">  CARMAWorldModel cmw; // Instantiate writeable world model</div>
<div class="line"> </div>
<div class="line">  // Build map</div>
<div class="line">  std::vector&lt;lanelet::Point3d&gt; left = {</div>
<div class="line">    getPoint(0, 0, 0), // user created helper function to make lanelet points</div>
<div class="line">    getPoint(0, 1, 0),</div>
<div class="line">  };</div>
<div class="line">  std::vector&lt;lanelet::Point3d&gt; right = {</div>
<div class="line">    getPoint(1, 0, 0),</div>
<div class="line">    getPoint(1, 1, 0),</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  auto ll = getLanelet(left, right); // user created helper function to make lanelets</div>
<div class="line">  auto map = lanelet::utils::createMap({ ll }, {});</div>
<div class="line"> </div>
<div class="line">  cmw.setMap(std::move(map));</div>
<div class="line"> </div>
<div class="line">  // User can now pass a shared pointer of cmw to whatever they wish to test</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><p> In the unit test, they can then intialize an instance of CARMAWorldModel, and set the map and route manually. NOTE: CARMAWorldModel should not be used in runtime code as the map route synchronization will need to be manually maintained.</p>
<h3><a class="anchor" id="autotoc_md17"></a>
Unit Test Example for WMTestLibForGuidance</h3>
<p >To better support unit testing for guidance components, a test library is made available with a world model that is with prebaked obstacles and several helper functions. In general, it includes the following :</p><ul>
<li>Helper functions to create the world from scratch or extend the world in <a class="el" href="namespacecarma__wm_1_1test.html#a8f15f836dede141bcabe292a0f9a1751" title="Gets the CARMAWorldModel for the guidance test map.">getGuidanceTestMap()</a></li>
<li>getGuidanceTestMap gives a simple one way, 3 lane map (25mph speed limit) with one static prebaked obstacle and <div class="fragment"><div class="line"> {c++}</div>
<div class="line">using namespace carma_wm::test</div>
<div class="line">TEST(UserTest, someTest)</div>
<div class="line">{</div>
<div class="line">  // get a premade world model for guidance unit test with default config</div>
<div class="line">  auto cmw_default = getGuidanceTestMap();</div>
<div class="line"> </div>
<div class="line">  // This premade map is configured through MapOptions class</div>
<div class="line">  // lanelet width and length is configurable. there are 4 lanelets in a single lane and 3 lanes in total. The default measures of a lanelet are 3.7 meter, and 25 meters respectively</div>
<div class="line">  MapOptions mp(5.0, 36);</div>
<div class="line">  auto cmw_configured = getGuidanceTestMap(mp);</div>
<div class="line"> </div>
<div class="line">  // there is option to either not include prebaked obstacle or set no speed limit</div>
<div class="line">  // MapOptions mp(5.0,36, MapOptions::Obstacle::NONE, MapOptions::SpeedLimit::NONE) also works</div>
<div class="line">  mp.speed_limit_ = MapOptions::SpeedLimit::NONE;</div>
<div class="line">  mp.obstacle_ = MapOptions::Obstacle::NONE;</div>
<div class="line">  auto cmw_configured1 = getGuidanceTestMap(mp);</div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li>addObstacle at a specified Cartesian relative to the local origin or Trackpos point relative to specified lanelet Id: <div class="fragment"><div class="line"> {c++}</div>
<div class="line">using namespace carma_wm::test</div>
<div class="line">TEST(UserTest, someTest)</div>
<div class="line">{</div>
<div class="line">  // set lanelet width and length to be 1,1</div>
<div class="line">  MapOptions mp(1,1);</div>
<div class="line">  auto cmw = getGuidanceTestMap(mp);</div>
<div class="line">  // add static obstacle by cartesian coords</div>
<div class="line">  // at 0.5,0.5, which is x,y object center</div>
<div class="line">  addObstacle(0.5,0.5,cmw);</div>
<div class="line">  // or add dynamic obstacle by cartesian coords with</div>
<div class="line">  // {0.25,1.5} predicted coord in the next 100ms (by default)</div>
<div class="line">  // and {0.5,2.5} in the next 100ms etc. 0.75, 0.75 width and length of the object</div>
<div class="line">  addObstacle(0.5,0.5, cmw, {{0.25,1.5}, {0.5,2.5}}, 100, 0.75, 0.75);</div>
<div class="line">  // similarily, add static obstacle by trackpos relative to given lanelet id</div>
<div class="line">  carma_wm::TrackPos tp = {0.5, 0};</div>
<div class="line">  carma_wm::TrackPos tp_pred = {1.5, -0.25};</div>
<div class="line">  addObstacle(tp, 1200, cmw, {}, 100, 0.75, 0.75);</div>
<div class="line">  // or add dynamic one, that is predicted to be at 1.5 downtrack and -0.25 crosstrack from </div>
<div class="line">  // lanelet is 1200 at the next 100ms. NOTE: This function only works on getGuidanceTestMap</div>
<div class="line">  addObstacle(tp, 1200, cmw, {tp_pred});</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li>set route by giving series of lanelet or their Ids in the map</li>
<li>or also overwrite the speed of the entire map <div class="fragment"><div class="line"> {c++}</div>
<div class="line">using namespace carma_wm::test</div>
<div class="line"> </div>
<div class="line">TEST(UserTest, someTest)</div>
<div class="line">{</div>
<div class="line">  auto cmw = getGuidanceTestMap(mp);</div>
<div class="line">  // set the route explicitly with all lanelet ids</div>
<div class="line">  setRouteByIds({1200,1210,1220,1221,1222,1223}, cmw);</div>
<div class="line">  // or let it route automatically by giving only start and end</div>
<div class="line">  setRouteByIds({1200, 1223}, cmw);</div>
<div class="line">  // we can also give lanelets themselves</div>
<div class="line">  auto ll_1200 = cmw-&gt;getMap()-&gt;laneletLayer.get(1200);</div>
<div class="line">  auto ll_1223 = cmw-&gt;getMap()-&gt;laneletLayer.get(1223);</div>
<div class="line">  setRouteByLanelets({ll_100, ll_1223}, cmw);</div>
<div class="line">  // overwrite all the speed limit of the entire road</div>
<div class="line">  setSpeedLimit(25_mph, cmw);</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li>add traffic light into the map <div class="fragment"><div class="line"> {c++}</div>
<div class="line">using namespace carma_wm::test</div>
<div class="line"> </div>
<div class="line">TEST(UserTest, someTest)</div>
<div class="line">{</div>
<div class="line">  auto cmw = getGuidanceTestMap(mp);</div>
<div class="line"> </div>
<div class="line">  // Light with default signal timers will be located on lanelet 1200 (entry) and exit at 1203.</div>
<div class="line">  // Notice that multiple entry and exit lanelets can be given.</div>
<div class="line">  lanelet::Id traffic_light_id = lanelet::utils::getId();</div>
<div class="line">  carma_wm::test::addTrafficLight(cmw, traffic_light_id, {1200}, { 1203 });</div>
<div class="line">  </div>
<div class="line">  // also timing can be changed:</div>
<div class="line">  std::vector&lt;std::pair&lt;boost::posix_time::ptime, lanelet::CarmaTrafficSignalState&gt;&gt; timing_plan =</div>
<div class="line">  {</div>
<div class="line">    std::make_pair&lt;boost::posix_time::ptime, lanelet::CarmaTrafficSignalState&gt;(lanelet::time::timeFromSec(0), lanelet::CarmaTrafficSignalState::PROTECTED_MOVEMENT_ALLOWED), // Just ended green</div>
<div class="line">    std::make_pair&lt;boost::posix_time::ptime, lanelet::CarmaTrafficSignalState&gt;(lanelet::time::timeFromSec(2.0), lanelet::CarmaTrafficSignalState::PROTECTED_CLEARANCE), // 2 sec yellow</div>
<div class="line">    std::make_pair&lt;boost::posix_time::ptime, lanelet::CarmaTrafficSignalState&gt;(lanelet::time::timeFromSec(17.0), lanelet::CarmaTrafficSignalState::STOP_AND_REMAIN), // 15 sec red</div>
<div class="line">    std::make_pair&lt;boost::posix_time::ptime, lanelet::CarmaTrafficSignalState&gt;(lanelet::time::timeFromSec(32.0), lanelet::CarmaTrafficSignalState::PROTECTED_MOVEMENT_ALLOWED) // 15 sec green</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  lanelet::Id traffic_light_id = lanelet::utils::getId();</div>
<div class="line">  carma_wm::test::addTrafficLight(cmw, traffic_light_id, {1200}, { 1203 }, timing_plan);</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --> </li>
</ul>
</li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Dec 7 2022 19:37:08 for Carma-platform by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
